# 미로를 헤매던 당신은 잠금장치가 있는 미로의 출구에 도착했습니다. 잠금장치는 n개의 버튼이 일렬로 배열되어 있으며, 가장 왼쪽에 있는 버튼부터 차례대로 1, 2, ... n의 번호로 위치를 표현합니다. 잠금장치를 해제하기 위해선 1 ~ m 사이의 정수 k개로 조합된 비밀번호를 입력해야 합니다. 잠금장치를 해제할 때마다 n개의 버튼 중 무작위 m개 위치에 1 ~ m 사이의 정수가 표시되며, 잠금장치에 표시된 1 ≤ a < b ≤ m 조건을 만족하는 두 정수 a, b에 대해, a가 b보다 번호가 낮은 위치에 표시됩니다. (즉, 잠금장치를 해제할 때마다 숫자 m개의 위치가 무작위로 다시 정해지며 - 이전과 같은 위치일 수도 있습니다 - 항상 오름차순으로 정렬된 상태로 표시됩니다)
#
# 다음은 8개의 버튼 중 무작위 4개의 위치에 1 ~ 4 사이의 정수가 표시된 예시입니다.
#
# 1 * 2 * 3 4 * *
# 1 2 3 4 5 6 7 8
# 미로의 잠금장치를 해제하기 위해서는 수가 표시된 버튼 m개를 올바른 순서대로 k번 눌러야 합니다. 위 그림과 같이 1, 3, 5, 6번 위치의 버튼에 1 ~ 4의 정수가 표시되었을 때, 비밀번호가 1 - 3 - 1 - 2라면 1, 5, 1, 3번 위치의 버튼을 순서대로 눌러야 합니다.
#
# 위 예시에서 올바른 버튼을 눌러 잠금장치를 해제한 뒤, 그다음 비밀번호를 입력할 때는 숫자의 위치가 무작위로 다시 정해집니다. 아래 그림은 그 예시입니다.
#
# 1 * 2 * 3 4 * *
# 1 2 3 4 5 6 7 8
# v v v v v v v v
# * 1 * 2 3 * * 4
# 1 2 3 4 5 6 7 8
#
# 숫자의 배치가 위와 같이 바뀌었다면, 비밀번호 1 - 3 - 1 - 2를 입력하기 위해선 2, 5, 2, 4번 위치의 버튼을 순서대로 눌러야 합니다.
# 이와 같이, 잠금장치를 풀기 위해 비밀번호를 입력할 때마다 숫자의 위치가 무작위로 다시 정해집니다.
# 당신은 먼저 미로를 나간 사람들이 누른 버튼의 위치를 바탕으로 잠금장치의 비밀번호를 추리해야 합니다.
#
# 다음은 버튼의 개수 n = 8, 표시되는 수의 범위 m = 4, 비밀번호의 길이 k = 4 일 때, 비밀번호를 추리하는 예시입니다.
#
# 기록	누른 버튼의 위치
# 기록 #1	1, 5, 1, 3
# 기록 #2	5, 7, 5, 6
# 기록 #1에서 비밀번호가 1 - 3 - 1 - 2, 1 - 4 - 1 - 2, 1 - 4 - 1 - 3 중 하나임을 알 수 있습니다.
#
# 누른 버튼의 위치가 총 3가지(1, 3, 5 위치) 이므로, 비밀번호는 3가지 수로 이루어져 있습니다.
# 1번 버튼을 눌렀으므로 숫자 1이 비밀번호에 포함됨을 알 수 있습니다. (수는 왼쪽부터 오름차순으로 표시되며 가장 작은 수는 1이기 때문입니다.)
# 5번 버튼에는 3번 버튼보다 큰 숫자가 표시됩니다.
# 따라서 5번 버튼에 표시된 숫자가 3이라면 비밀번호는 1 - 3 - 1 - 2이며, 5번 버튼에 표시된 숫자가 4라면 비밀번호는 1 - 4 - 1 - 2 또는 1 - 4 - 1 - 3입니다.
# 비밀번호가 1 - 3 - 1 - 2인 경우, 각 정수가 표시된 버튼의 위치는 아래 그림과 같습니다.
#
# 1 * 2 * 3 ? ? ?
# 1 2 3 4 5 6 7 8
#
# 비밀번호가 1 - 4 - 1 - 2인 경우, 각 정수가 표시된 버튼의 위치는 아래 그림과 같습니다.
# 1 * 2 3 4 * * *
# 1 2 3 4 5 6 7 8
#
# 비밀번호가 1 - 4 - 1 - 3인 경우, 각 정수가 표시된 버튼의 위치는 아래 그림과 같습니다.
# 1 2 3 * 4 * * *
# 1 2 3 4 5 6 7 8
#
# 기록 #2에서는 숫자의 위치가 다시 랜덤하게 정해졌습니다.
#
# 기록 #2에서 비밀번호가 인접한 3개의 정수([1, 2, 3] 또는 [2, 3, 4])로 구성된 것을 알 수 있습니다.
#
# 비밀번호가 1 - 3 - 1 - 2인 경우, 각 정수가 표시된 버튼의 위치는 아래 그림과 같습니다.
# * * * * 1 2 3 4
# 1 2 3 4 5 6 7 8
#
# 비밀번호가 2 - 4 - 2 - 3인 경우, 각 정수가 표시된 버튼의 위치는 아래 그림과 같습니다.
# ? ? ? ? 2 3 4 *
# 1 2 3 4 5 6 7 8
#
# 두 가지 단서를 조합하면 비밀번호가 1 - 3 - 1 - 2임을 알아낼 수 있습니다.
#
# 버튼의 개수를 나타내는 정수 n, 표시되는 수의 범위를 나타내는 정수 m, 비밀번호의 길이를 나타내는 정수 k와 먼저 미로를 나간 사람들의 버튼을 누른 기록이 담긴 2차원 정수 배열 records가 매개변수로 주어집니다. 이때, 잠금장치의 비밀번호를 정수 배열에 담아 return 하도록 solution 함수를 완성해주세요.
#
# 단, 가능한 비밀번호가 여러 개라면, 비밀번호에 등장하는 중복을 제외한 수들을 오름차순으로 정렬했을 때, 사전 순으로 가장 뒤에 위치하는 비밀번호를 return 해야 합니다.
#
# 제한사항
# 3 ≤ n ≤ 200,000
# 1 ≤ m ≤ n
# 1 ≤ k ≤ 5,000
# 1 ≤ records의 길이 ≤ 1,000
# records[i]의 길이 = k
# records[i]의 j번째 원소는 먼저 미로를 나간 i번째 사람이 j번째로 누른 버튼의 위치를 나타냅니다.
# 1 ≤ records[i][j] ≤ n
# 항상 비밀번호를 올바르게 입력하고 미로에서 탈출한 경우만 입력으로 주어집니다.
n, m, k, records = 8, 4, 4, [[1, 5, 1, 3], [5, 7, 5, 6]]

def solution(n, m, k, records):

    pos_btn = [i+1 for i in range(m)]
    ans = []
    visited = [0]*(m+1)

    def btrk(x):
        if x==m:
            return x

        else:
            for nodes:
                if possible:
                    to node of son
                    btrk(x+1)
                    to parent node






    answer = []
    return answer



x = solution(n, m, k, records)
print(x)
